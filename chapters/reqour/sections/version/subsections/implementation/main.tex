\documentclass[../main.tex]{subfiles}

\begin{document}

The version endpoint handler implementation is straightforward: it just fills the DTO by values generated during build time: \textit{name} is taken from \textit{quarkus.application.name} config property\footnote{\url{https://quarkus.io/guides/all-config##quarkus-core_quarkus-application-name}}. Another values are generated by \textit{maven-replacer-plugin}\footnote{\url{https://mvnrepository.com/artifact/com.google.code.maven-replacer-plugin/maven-replacer-plugin}}, which creates \textit{BuildInformationConstants} class containing all values as static fields during build time. Consecutively, these values are taken and pasted into the response DTO by the version handler. The whole implementation\footnote{\url{https://github.com/project-ncl/reqour/blob/akridl-thesis/rest/src/main/java/org/jboss/pnc/reqour/rest/endpoints/VersionEndpointImpl.java}} is shown in the Listing \ref{lst:version-impl}.

\begin{lstlisting}[language=Java, caption=Implementation of version endpoint, label={lst:version-impl}]
@ApplicationScoped
public class VersionEndpointImpl implements VersionEndpoint {

    @ConfigProperty(name = "quarkus.application.name")
    String name;

    @Override
    public ComponentVersion getVersion() {
        return ComponentVersion.builder()
                .name(name)
                .version(BuildInformationConstants.VERSION)
                .commit(BuildInformationConstants.COMMIT_HASH)
                .builtOn(ZonedDateTime.parse(BuildInformationConstants.BUILD_TIME))
                .build();
    }
}
\end{lstlisting}

\subsubsection*{PRs}
\subfile{./subsubsections/prs}

\end{document}
